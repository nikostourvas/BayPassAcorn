### Running poolfstat and baypass ###
### @Devrim Semizer-Cuming, January 2024 ###

## Notes: 
## (1) The code is tested on a subset of Q. robur snps generated for the ACORN project. 
## (2) The majority of it runs in R except for baypass which runs on the Terminal. 
## (3) R version 4.3 (in the Terminal on Debian-Linux platform) is used for the analysis. The script may require further adjustments for RStudio.
## (4) Package version info: poolfstat 2.2.0; baypass 2.4

#########################################################################
## Computing f-statistics based on pool-seq read counts with poolfstat ##
#########################################################################
# load libraries
library(poolfstat)
library(xlsx)

# set working directory
setwd("/local_disks/disk_3/BayPassAcorn")

# generate a pooldata object
psizes <- as.numeric(c('40', '34', '40', '40', '40', '38', '40', '36', '40', '40', '40', '40', '34', '32', '40', '40', '40', '40', '40', '30', '40', '40', '40', '34', '40', '40', '40', '40', '34', '34', '40', '38', '40', '40', '34', '32', '38', '40', '40', '40'))
pnames <- as.character(c('300', '308', '320', '364', '390', '312', '301', '309', '321', '365', '324', '302', '310', '340', '384', '366', '325', '303', '311', '341', '385', '367', '304', '342', '386', '322', '305', '313', '343', '387', '323', '306', '314', '362', '388', '360', '307', '315', '363', '389'))

poolreadcount <- vcf2pooldata(vcf.file = "Data/ACORN_VCF_Qrobur_minCov20IndelFilteredSNPs_Biallelic_miss0.1_ADP104_Subsampled_0.01.vcf", 
			poolsizes = psizes, poolnames = pnames)
poolreadcount

# estimate genome-wide Fst over all populations
poolreadcount.fst <- computeFST(poolreadcount)
poolreadcount.fst$FST

# estimate std error and confidence intervals (Block-Jackknife)
poolreadcount.fst <- computeFST(poolreadcount, nsnp.per.bjack.block = 1000, verbose = FALSE)
poolreadcount.fst$FST # genome-wide Fst over all populations
poolreadcount.fst$mean.fst # Block-Jackknife estimate of s.e.
poolreadcount.fst$se.fst # s.e. of the genome-wide Fst estimate
poolreadcount.fst$mean.fst+c(-1.96,1.96)*poolreadcount.fst$se.fst # 95% c.i. of the estimated genome-wide Fst

# compute multilocus Fst to scan the genome over sliding-windows of SNPs  
poolreadcount.fst <- computeFST(poolreadcount, sliding.window.size = 50) 

# generate and save the plot
png(file = "Results/manhattanPlot.png", width = 600, height = 350)
plot(poolreadcount.fst$sliding.windows.fst$CumulatedPosition/1e6,
     poolreadcount.fst$sliding.windows.fst$MultiLocusFst,
     xlab = "Cumulated Position (in Mb)", ylab = "Multilocus Fst",
     col = as.numeric(as.factor(poolreadcount.fst$sliding.windows.fst$Chr)), pch = 16)
abline(h = poolreadcount.fst$FST, lty = 2)
dev.off()

# compute pairwise population Fsts
pairwisefst <- compute.pairwiseFST(poolreadcount, verbose = FALSE)

# generate and save the heatmap
pdf(file = "Results/heatmap.pdf")
heatmap(pairwisefst)
dev.off()

# save the pairwise matrix
p.fst <- pairwisefst@PairwiseFSTmatrix
p.fst <- as.data.frame(p.fst)
write.xlsx(p.fst, "Results/p.fst.matrix.xlsx", sheetName = "Matrix", col.names = TRUE, row.names = TRUE, append = FALSE)

# estimate std error and confidence intervals (Block-Jackknife)
pairwisefst <- compute.pairwiseFST(poolreadcount, nsnp.per.bjack.block = 1000, verbose = FALSE)
head(pairwisefst@values)

# save the plot
png(file = "Results/pairwiseFst.png", width = 600, height = 350)
plot(pairwisefst)
dev.off()

# subset the data if needed (e.g.)
# subset.by.snps = poolreadcount.subset(poolreadcount, snp.index = 1:10000)

# convert the pooldata object to BayPass input files (i.e. genobaypass, snpdet, poolsize)
pooldata2genobaypass(poolreadcount, writing.dir = "Data/", subsamplesize = -1) # or writing.dir = getwd()

#########################################
## Detecting outlier loci with baypass ##
#########################################

## Notes: 
## (1) This part of the code is run directly from the command line in the Terminal.
## (2)-d0yij = 1/5 of min haploid pool size; use npilot = 100 for final analysis (see the Manual for detailed parameter descriptions).
## (3) baypass is not scaling linearly with the no of threads; analyze subsets of data on single threads in parallel; pooldata.subset() function in poolfstat can be used.
## (4) Option 3: Contrast analysis is applied on the subsetted ACORN data!

## Option 1. Scanning the genome for differentiation (without covariate) 
# running core model for scanning the genome for differentiation using the XtX statistics
~/bin/baypass_2.4/sources/g_baypass -nthreads 10 -npop 40 -gfile ./Data/genobaypass -poolsizefile ./Data/poolsize -d0yij 6 -outprefix ./Results/Qrobur 

## Option 2. Identifying SNPs associated with population covariate data
## Note: Default is Importance Sampling (IS) covariate mode; activate MCMC mode with covmcmc ; activate auxiliary model with auxmodel
# running standart covariate model (STD) estimating Bayes Factor (BF): parametric
~/bin/baypass_2.4/sources/g_baypass -nthreads 10 -npop 40 -gfile ./Data/genobaypass -poolsizefile ./Data/poolsize -d0yij 6 -efile ecotype -outprefix QroburCov

# Option 3. Running contrast analysis estimating C2 statistic: population ecotype is a binary trait (dry = -1; moist = 1)
~/bin/baypass_2.4/sources/g_baypass -nthreads 10 -npop 40 -gfile ./Data/genobaypass -poolsizefile ./Data/poolsize -d0yij 6 -contrastfile ./Data/ecotype -efile ./Data/ecotype -outprefix ./Results/QroburCon

#####################################
## Processing baypass outputs in R ##
#####################################

# plot the resulting C2 and BF estimates and compare them
Qrobur.ecotype.BF = read.table("Results/QroburCon_summary_betai_reg.out", h = T)$BF.dB.
Qrobur.ecotype.C2 = read.table("Results/QroburCon_summary_contrast.out", h = T)

# check the behavior of the p-values associated to C2
## Note: If p-values do not behave well, try removing low polymorphic snps to help deflating them.
pdf(file = "Results/Hist_pVal_C2.pdf")
hist(10**(-1*Qrobur.ecotype.C2$log10.1.pval.), freq = F, breaks = 50)
abline(h = 1)
dev.off() 

pdf(file = "Results/BF-C2_Comp.pdf")
plot(Qrobur.ecotype.BF, Qrobur.ecotype.C2$log10.1.pval.,
xlab = "BF", ylab = "C2 p-value (-log10 scale)")
abline(h = 3, lty = 2) # 0.001 p-value theshold
abline(v = 20, lty = 2) # BF threshold for decisive evidence (according to Jeffreysâ€™ rule)
dev.off()

###################################################################
## Calibrating statistics with presudo-observed data sets (PODs) ##
###################################################################

## Note: Normally, calibration is used for XtX statistic (Option 1), not for C2. However, if the p-value distribution is still problematic after removing low polymorphic SNPs and you want to use PODs then you can compute empirical p-values using empPvals function of the qvalue package in R. 

# source the BayPass R functions
source("~/bin/baypass_2.4/utils/baypass_utils.R")

## 1. Generating the POD
# get estimates (post.mean) of the a_pi and b_pi parameters of the pi beta distribution
pi.beta.coef = read.table("Results/QroburCon_summary_beta_params.out", h = T)$Mean

# upload the original data to obtain total read counts
Qrobur.data <- geno2YN("Data/genobaypass")

# create pseudo-observed datasets (PODs)
Qrobur.sim <- simulate.baypass(omega.mat = omega, nsnp = 10000, sample.size = Qrobur.data$NN,
beta.pi = pi.beta.coef, pi.maf = 0.05, suffix = "Qroburpods")

# run BayPass in the Terminal to analyze the PODs
~/bin/baypass_2.4/sources/g_baypass -nthreads 5 -npop 40 -gfile ./Results/G.Qroburpods -poolsizefile ./Data/poolsize -d0yij 6 -efile ./Data/ecotype -outprefix anaQroburpods

## 2. Comparing the POD and original data estimates for sanity check
# get the estimate of omega from the POD analysis
pod.omega = as.matrix(read.table("Results/pods/anaQroburpods_mat_omega.out"))

pdf(file = "Results/Omega_comp.pdf")
plot(pod.omega, Qrobur.omega)
abline(a = 0, b = 1)
dev.off()

pdf(file = "Results/Omega_comp.pdf")
plot(pod.omega, Qrobur.omega)
coef <- coef(lm(Qrobur.omega ~ pod.omega))
abline(coef[1], coef[2], col = "red", lwd = 1.5)
dev.off()

# get Forstner and Moonen Distance (FMD) between simulated and original posterior estimates (the smaller the better)
fmd.dist(pod.omega, Qrobur.omega)

# get estimates of the a_pi and b_pi parameters of the pi beta distribution from the POD analysis
pod.pi.beta.coef = read.table("Results/pods/anaQroburpods_summary_beta_params.out", h = T)$Mean

pdf(file = "Results/Coef_comp.pdf")
plot(pod.pi.beta.coef, pi.beta.coef)
abline(a = 0, b = 1)
dev.off()

## 3. Calibrating XtX and detecting outliers
# get the POD XtX estimates
pod.xtx = read.table("Results/pods/anaQroburpods_summary_pi_xtx.out", h = T)$M_XtX

# compute e.g. 1% threshold 
pod.thresh = quantile(pod.xtx, probs = 0.99)
pod.thresh

# get the original XtX estimates (for Option 1)
snp.res = read.table("Results/QroburCon_summary_pi_xtx.out", h = T)

# add the threshold to the original XtX plot
pdf(file = "Results/Plot_snps.pdf")
plot(snp.res$M_XtX)
abline(h = pod.thresh,lty = 2, col = "red", lwd = 2)
dev.off()

# save XtX values of the SNPs and filter them for XtX > pod.thresh for outliers
snp.scores <- as.data.frame(snp.res$M_XtX)

# join two files (snpdet and snp.scores)
snp.info <- read.table("Data/snpdet", sep = "", header = F, check.names = F)
names(snp.info) <- c("chr", "pos", "ref", "alt")

merged <- cbind(snp.info, snp.scores)
write.table(merged, file = "Results/Qrobur.snp.scores.txt", sep = "\t", row.names = F)

